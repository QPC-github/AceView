/*  File: aceclient.c
 *  Author: Jean Thierry-Mieg (mieg@kaa.cnrs-mop.fr)
 *  Copyright (C) J Thierry-Mieg and R Durbin, 1992
 *-------------------------------------------------------------------
 * This file is part of the ACEDB genome database package, written by
 * 	Richard Durbin (MRC LMB, UK) rd@mrc-lmb.cam.ac.uk, and
 *	Jean Thierry-Mieg (CRBM du CNRS, France) mieg@kaa.cnrs-mop.fr
 *
 *
 * Description:
 * I started from a sample code generated by rpcgen on Solaris
 * and a first version by Peter Kocab.
 * 
 * Exported functions:
 * HISTORY:
 * Last edited: Dec  2 15:56 1998 (edgrif)
 * * Dec  2 15:55 1998 (edgrif): Correct decl. of main, add code to
 *              record build time of this module.
 * Created: Wed Nov 25 20:02:45 1992 (mieg)
 *-------------------------------------------------------------------
 */

 /* $Id: aceclient.c,v 1.8 2011/10/09 03:13:22 mieg Exp $ */

#include "regular.h"
#include "array.h"
#define __malloc_h
#include <errno.h>
#include "../wh/aceclient.h"
#include "version.h"

static int nAceIn = 0;
static int chunkSize = 10;

extern int accessDebug ; /* in aceclientlib.c */
void tStatus (void) { return ; } /* missing in the client */

char *prompt = ">";


 /*************************************************************************/

static char* getAceLevel (int level, int limit, BOOL mask)
{ static Stack s = 0 ;
  BOOL in = FALSE ;
  char *cp, cutter ;
  int nn = 1 ;

  s = stackReCreate (s, 30000) ;

  if (mask) pushText (s, "parse = ") ;
  while (freecard (level))
    { cp = freewordcut("\n" ,&cutter) ;
      if (cp && *cp)
	{ if (!in)
	    { nn++ ;
	      nAceIn++ ; in = TRUE ;
	    }
	  catText (s, cp) ;
	  if (mask) catText (s, "\\n") ;
	  else catText (s, "\n") ;
	}
      else
	{ if (mask) catText (s, "\\n") ;
	  else catText (s, "\n") ;
	  in = FALSE ;
	  if (limit && !(nn % limit))
	    break ;
	}
    }
  return nn > 1 ? stackText (s, 0) : 0 ;
}

/*************************************************************************/

static char* getAceData ()
{ 
  int level = freesetfile (stdin,"") ;
  char *cp ;

  freespecial ("\n/\\\"\t@") ;
  
  cp = getAceLevel (level, 0, TRUE) ;
  freeclose (level) ;
  return cp ;
}

/*************************************************************************/

static char* getOrder(int level, BOOL silent, 
		      BOOL isAceIn, BOOL isAceOut, BOOL isReport, char *host)
{ char *cp = 0, cutter, *errtext;
  int np ;
  static Stack s = 0 ;
  
  if (isAceIn)
    return getAceLevel (level, 500, FALSE) ;
 lao:
  cutter = 0 ;   
  cp = freewordcut(isReport ? "#" : "" ,&cutter) ;
  if ((!cp && !cutter)  ||
      (cp && *cp == '/' && *(cp+1) == '/'))
    { if (!silent)
      { printf("%s",prompt); fflush(stdout); }
      if (!level || !freecard (level))
	return 0 ;                       /* just get a card */
      if (isReport && (!cp || *cp != '/'))
	{ putchar ('\n') ;fflush(stdout); }
      goto lao ;
    }

  if (!silent || isAceOut)
    return cp ;   /* the whole line will be processed by the server */
  
    /* Now silent = TRUE and we are in report mode*/

  if (!cutter)    /* just print out the line */
    { if (cp)
      { printf("%s",cp) ;fflush(stdout); }
      goto lao ;
    }
  if (cp)
    { printf("%s",cp) ; /* print the beginning */
      fflush(stdout);
    }
  s = stackReCreate(s, 50) ;
  pushText(s,"") ;
  
  if (!freestep('('))
    { putchar (cutter) ; goto lao ; }

  np = 1 ;
  while (np && (cp = freewordcut("()" ,&cutter)))
    { catText(s, cp) ;
      switch (cutter)
	{ 
	case '(':
	  catText(s,"(") ;
	  np++ ;
	  break ;
	case ')':
	  np-- ;
	  if (np)
	    catText(s,")") ; 
	  break ;
	case 0:
	  if (np)
	    { errtext = "Missing right parenthese" ;
	      goto error ;
	    }
	}
    }
  cp = stackText(s,0) ;
  return cp ;  /* let the server process this command */

 error:
  printf("//! %s after %% in %s\n", errtext, stackText(s,0)) ;
  cp = freepos() ;
  if (cp)
    printf("//! %s",cp) ;
  fflush(stdout);
  goto lao ;
}

/***************************************************************************/

/* Defines a routine to return the compile date of this file.                */
UT_MAKE_GETCOMPILEDATEROUTINE()



int main(int argc, char *argv[])
{
  void *handle; /* JC do not need to know what it is */
  char *host, *cp ;
  unsigned char *answer;
  int   
    n, retval,
    length,
    t, timeOut = 300 ,
    level, encore = 0 ;
  unsigned long port = DEFAULT_PORT;
  unsigned long p;
  BOOL 
    silent = FALSE, doWrite = TRUE , isReport = FALSE, encoring,
    isAceIn = FALSE, isAceOut = FALSE, isQuit = FALSE, isShutdown = FALSE ;
  FILE *fil = 0 ;
  Stack s = 0 ;
  
  if ( argc < 2 ) 
    goto abort ;
  host = argv[1] ;
  cp = host ;
  /* accept 'host:port' as a short hand for  'host -port  port' */
  while (*cp && *cp != ':') cp++ ;
  if (*cp == ':')
    {
      *cp++ = 0 ;
      if (strlen(cp) > 0 &&
	  sscanf(cp,"%lu",&p)== 1)
	port = p ;
    }

  freeinit();

  n = 2 ;
  if ( argc > n + 1 && !strcmp("-port", argv[n]))
    { if (sscanf(argv[n+1],"%lu",&p)== 1)
	{ port = p ;
	  n += 2 ;
	}
      else
	goto abort ;
    }
  if ( argc > n + 1 && !strcmp("-time_out", argv[n]))
    { if (sscanf(argv[n+1],"%ic",&t)== 1)
	{ timeOut = t ;
	  n += 2 ;
	}
      else
	goto abort ;
    }

  if (argc > n && (!strcmp("-access_info", argv[n]) || !strcmp("access_info", argv[n])))
	{ accessDebug = TRUE ;
	  n++ ;
	}

  if (argc > n && (!strcmp("-ace_out", argv[n]) || !strcmp("ace_out", argv[n])))
	{ isAceOut = TRUE ;
	  silent = TRUE ;
	  n++ ;
	}

  if (argc > n && (!strcmp("-ace_in", argv[n]) || !strcmp("ace_in", argv[n])))
	{ isAceIn = TRUE ;
	  encore = 3 ;
          /* silent = TRUE ; */
	  fil = stdin ;
	  n++ ;
	}

  if (argc > n && (!strcmp("-prompt", argv[n])))
	{
	n++;
	if (argv[n])
		{
		prompt=strdup(argv[n]);
		if (prompt[strlen(prompt)-1] == '$')
			prompt[strlen(prompt)-1]='\n';
		}
	n++ ;
	}
  else
	{
	static char interactive_prompt[100];
	sprintf(interactive_prompt,"acedb@%s> ", host);
	prompt = interactive_prompt;
	}

  if (argc > n)
    { if (!strcmp("-f", argv[n]))
	{ n++ ;
	  silent = TRUE ;
	  isReport = TRUE ;
	  fil = fopen(argv[n],"r") ;
	  if (!fil)
	    {
	      printf("//! Cannot open file %s given on command line \n", argv[n]) ;
	      fflush(stdout);
	      goto abort ;
	    }
	}
      else
	goto abort ;
    }

  s = stackReCreate(s,50) ;  
  s->textOnly = TRUE ;
  pushText(s,"") ;

  if (argc > n)
    { int i ;
      n++ ;
      for (i= n ; i < argc ; i++)
	{ catText(s, argv[i]) ;
	  catText(s, " ") ;
	}
    }

  if (!fil)
    fil = stdin ;
  level = freesetfile(fil, stackText(s,0)) ;
  if (isReport)
    freespecial ("\n\t\"\\@%$") ; /* no // (to echo empty lines), allow client-side sub shells */
  else
    freespecial ("\n\t\"\\/@%$") ; /* allow client-side sub shells */

  if ((handle = openServer(host, port, timeOut)) == NULL)
    { printf("//! cannot establish connection\n") ; 
      fflush(stdout);
      goto abort;
    }
#ifdef DEBUG
  else
    printf("opened connection to %s on port %lu\n\n",host,port);
#endif

  while((cp = getOrder(level, silent, isAceIn, isAceOut, isReport, host)))
    { 
if (0) printf("-->%s<--\n",cp);
      if (strncasecmp(cp, "query", 5) &&
	  ace_lower(*cp) == 'q')  /* quit command */
	{ cp = "quit" ;
	  isQuit = TRUE ;  /* transmit the quit to the server */
	}
      if (!strncasecmp(cp, "shutdown", 8))
	isShutdown = TRUE ;
      else
	isShutdown = FALSE ;

      doWrite = TRUE ;
      if (isAceOut && strncasecmp(cp,"Write",5) && strncasecmp (cp, "Table", 5))
	doWrite = FALSE ;
      if (!strncasecmp(cp, "parse", 5))
	{
	  cp = getAceData () ;
	  if (!cp) continue;
	}
      encoring = FALSE ;
    suiteReponse:
      retval = askServerBinary (handle, cp, &answer, &length, &encore, chunkSize) ;
      if (isShutdown && retval == 5)
	{ printf("// The server has disconnected\n\n") ; /* DWB - report error code */
	exit (0) ;
	}
      if (isQuit) break ; /* reply is null */
      if (retval > 0)  /* error handling */
	{ printf ("//! Null answer - Error Code: %d\n", retval) ; /* DWB - report error code */
	  printf ("//! You may have timed out") ;
	  break ;
	}
      if (!encore && !answer) /* error handling */
	{ printf("//! Null reponse, you may have timed out \n") ;
	  if (silent || messQuery("// Do you want to quit (y/n) ?"))
	    break ;
	  continue ;
	}

      if (length && !encoring && !silent)
	printf ("// Reponse: %d bytes.\n", length) ;

      s = stackReCreate (s,length) ;
      stackTextForceFeed (s, length) ;
      memcpy (stackText(s,0), answer, length) ;
      free (answer);

      stackCursor(s, 0) ;
   
      if (doWrite)
	{ while ((cp = stackNextText(s)))
	    {
	      if ((silent || (encore && encore != 3)) && (!*cp || *cp == '/'))
		continue ;
 
	      if (silent)  /* jump // lines */
		{ register char *cp1 = cp, *cp2, cc ;
		  while (*cp1)
		    { cp2 = cp1 ;
		      while (*cp2 && *cp2 != '\n') cp2++ ;
		      cc = *cp2 ; *cp2 = 0 ;
		      if (!(*cp1 == '/' && *(cp1 + 1) == '/'))
			puts (cp1) ;
		      if (cc) *cp2++ = cc ;
		      cp1 = cp2 ;
		    }
		}
	      else
		{ 
		  if (*cp)
		    { register char *cp1 = cp + strlen(cp) - 1 ;
		      if (cp1 >= cp && *cp1 == '\n')
			*cp1 = 0 ; /* because puts adds a terminal \n */
		      if (*cp) puts (cp) ; else putchar('\n') ;
		    }
		}
	    }
	}
      if (isAceIn)
	continue ;
      if (encore)
	{ encoring = TRUE ; cp = "encore" ;
	  goto suiteReponse ; /* get rest of data */
	}
    }

  closeServer(handle);
  if (!silent)
    printf("\n// Please report problems to mieg@ncbi.nlm.nih.gov\n //Bye\n\n") ;
  if (isAceIn)
    printf ("\n// Passed %d objects to the server, \n// ciao bye \n\n", nAceIn) ;
  return(EXIT_SUCCESS) ;

 abort:
  fprintf(stderr, 
	  "//! usage: aceclient host [-port number] [-time_out secs] "
	  "[-access_info] [-ace_out] [-ace_in] [-f reportfile parameters]\n") ;
  return(EXIT_FAILURE) ;
}

/*************************************************************************/
/*************************************************************************/
 
 
