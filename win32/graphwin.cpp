/* graphwin.cpp : implementation file
 *  Author: Richard Bruskiewich, rbrusk@octogene.medgen.ubc.ca
 *  Copyright (C) R. Bruskiewich, J Thierry-Mieg and R Durbin, 1996
 *-------------------------------------------------------------------
 * This file is part of the ACEDB genome database package, written by
 * 	Richard Durbin (MRC LMB, UK) rd@mrc-lmb.cam.ac.uk, and
 *	Jean Thierry-Mieg (CRBM du CNRS, France) mieg@kaa.cnrs-mop.fr
 *
 * Description: 
 * HISTORY:
 * Last edited: Jun 10 10:15 1996 (rbrusk):
 *		-	consolidated code into CGraphWindow which seemed appropriate
 *			including the messagebox, graphloop and general device management
 *		-	implemented graphWaitCursor() (the XWindows way; may not work well in WIN32?)
 * Created: Jul 21 18:40 1995 (rbrusk)
 *-------------------------------------------------------------------
 */
 /* $Id: graphwin.cpp,v 1.1.1.1 2002/07/19 20:23:25 sienkiew Exp $ */

#include "stdafx.h"
#include "win32.h"
#include "winace.h"
#include "mainfrm.h"
#include "cgraph.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGraphWindow

IMPLEMENT_DYNCREATE(CGraphWindow, CMDIChildWnd)

///////////////////////////////////////////////////////////////////////////////////////
// nextControlID() dynamically assigns a new WM_COMMAND ID number for graph "controls"
// To trick the resource.h file to define _APS_NEXT_CONTROL_VALUE
#define APSTUDIO_INVOKED
#include "resource.h"

int CGraphWindow::nextControlID()
{
	static UINT nextID = _APS_NEXT_CONTROL_VALUE ; // pick up where AppStudio left off
	return nextID++ ;
}

CGraphWindow::CGraphWindow()
{
	m_MessageWndID = nextControlID() ;
	m_pMessageWnd = NULL ;
}

void CGraphWindow::DeleteBoxViews()
{
	// Destroy all boxViews
	int maxbox = m_boxViews.GetUpperBound() ;
	for( int i = 0; i <= maxbox; ++i )
	{
		CGraphBox *GBox = m_boxViews.GetAt(i) ;
		delete GBox ;
	}
	m_boxViews.RemoveAll() ;
}

CGraphWindow::~CGraphWindow()
{
	if( m_pMessageWnd )
	// in case there is a MESSAGE_DESTROY callback 
	CloseGraphMessage() ;

	DeleteBoxViews() ;
}

BEGIN_MESSAGE_MAP(CGraphWindow, CMDIChildWnd)
	//{{AFX_MSG_MAP(CGraphWindow)
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
	ON_WM_SYSCOMMAND()
	ON_WM_CHILDACTIVATE()
	ON_COMMAND(ID_KEY_DOWN, OnDownArrow)
	ON_COMMAND(ID_KEY_LEFT, OnLeftArrow)
	ON_COMMAND(ID_KEY_RIGHT, OnRightArrow)
	ON_COMMAND(ID_KEY_UP, OnUpArrow)
	ON_WM_ACTIVATE()
	ON_WM_NCHITTEST()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Default Graph Size at start of program is whole screen?
int CGraphWindow::m_def_left = 0 ;
int CGraphWindow::m_def_top = 0 ;
int CGraphWindow::m_def_width = CGraphView::gScreenX ;
int CGraphWindow::m_def_height = CGraphView::gScreenY ;

/////////////////////////////////////////////////////////////////////////////
// CGraphWindow diagnostics

#ifdef _DEBUG
void CGraphWindow::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CGraphWindow::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc) ;

	dc << "\n\tGraph Boxes:\n" ;
	m_boxViews.Dump( dc ) ;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGraphWindow message handlers

void CGraphWindow::OpenGraphMessage( const CString& text )
{
	// ignore additional calls to OpenGraphMessage()
	// generated by redundant graphMessage() calls
	if(	m_pMessageWnd ) return ;

	CString msgTitle = GetGraph()->name ;
	msgTitle += " Message" ;

	m_pMessageWnd = new CMsgWindow( msgTitle, text, this) ;

}

void CGraphWindow::CloseGraphMessage( BOOL flg ) // flg is a dummy parameter
{
	// block recursive calls: window already destroyed?
	if( !m_pMessageWnd ) return ;

	// for blocking recursive calls...
	CMsgWindow *pMW = (CMsgWindow *)m_pMessageWnd ;
	m_pMessageWnd = 0 ;
	
	// Note: func[MESSAGE_DESTROY]() sometimes recursively calls
	//       CloseGraphMessage() (via graphUnMessage() ) hence the block above
	if( gActive->func[MESSAGE_DESTROY] )
		(gActive->func[MESSAGE_DESTROY])() ;
		
	// Send this message to the base class of CMsgWindow
	pMW->DestroyWindow() ;
}

void CGraphWindow::InitDevStruct(Graph_ graph, int x, int y, int w, int h)
{
	// Set Graph (Child Window) Position and Size within MainFrame window

    m_def_left = x;
	m_def_top  = y;
	m_def_width  = graph->w	= w ;
	m_def_height = graph->h	= h ;

	// Graph type specific actions
	switch( graph->type )
	{
		// Set undefined uw and uh window size parameters
		// now that you have device info handy
		case PIXEL_FIT:
		case TEXT_FIT:
		case TEXT_SCROLL:
		case TEXT_FULL_SCROLL:
		case TEXT_FULL_EDIT:
			graph->uw = XtoUrel(graph->w) ; 
			graph->uh = YtoUrel(graph->h) ;
			break ;

		case PLAIN:
		case MAP_SCROLL:
		case PIXEL_SCROLL:
			break ;  // uw, uh already set elsewhere?

		default: 
			messcrash ("Invalid graph type %d requested in graphDevCreate()",graph->type) ;
	}
}

BOOL CGraphWindow::PreCreateWindow(CREATESTRUCT& cs) 
{
	CPoint pt = GetGraphOrigin() ;
	cs.x = pt.x; cs.y = pt.y;
		
	return CMDIChildWnd::PreCreateWindow(cs);
}

void CGraphWindow::OnPaletteChanged(CWnd* pFocusWnd) 
{
	
	if(pFocusWnd == this ) return ;
	// else...
	VERIFY( OnQueryNewPalette() );
  
	// CMDIChildWnd::OnPaletteChanged(pFocusWnd); // base class call not needed?
	
}

extern CPalette gPalette ;

BOOL CGraphWindow::OnQueryNewPalette() 
{
	CDC *dc = GetDC();
	ASSERT_VALID( dc ) ;

    CPalette *hOldPal = dc->SelectPalette( &gPalette, FALSE);
	ASSERT_VALID( hOldPal ) ;

    UINT i = dc->RealizePalette( );
    if (i != 0) {
        InvalidateRect( NULL, TRUE); 
    }

    dc->SelectPalette( hOldPal, TRUE);
    dc->RealizePalette( );
    ReleaseDC( dc );
	return i ;
	
	// return CMDIChildWnd::OnQueryNewPalette();
}

extern "C" void winExit( int exitcode ) ;
extern "C" BOOL graphIsBlocked() ;

void CGraphWindow::OnSysCommand(UINT nID, LPARAM lParam) 
{

#if !defined(NEW_WIN32_GRAPHS)
	CGraph *pGraph = (CGraph *)GetActiveDocument() ;
	int gID = pGraph->GetGraph()->id ;
#else
	int gID = GetGraph()->id ;
#endif

	graphActivate( gID ) ;
	if( graphIsBlocked() ) return ;

	if( nID == SC_CLOSE ) // Is the user closing the window?
	{
		if(	gID == 1 ) // Is this the Main ACEDB Graph?
			winExit(0) ;	// then, close the database down?
		else // if graph not blocked, then destroy it
			graphDestroy() ;
	}	
	// otherwise, pass through other Windows SYSCOMMANDS
	// to MDI child frame base class
	else CMDIChildWnd::OnSysCommand(nID, lParam);
}

CGraphStruct *CGraphWindow::GetGraph( BOOL flg ) 
{
#if !defined(NEW_WIN32_GRAPHS)
	CGraph *pGraphDev = (CGraph *)GetActiveDocument() ;
	ASSERT_VALID( pGraphDev ) ;
	return( pGraphDev->GetGraph() ) ;
#else
	return (CGraphStruct *)(((CGraphView *)GetActiveView())->GetGraph()) ;
#endif
}

#if defined(NEW_WIN32_GRAPHS)
void CGraphWindow::Activate(BOOL flg)
{
	MDIActivate() ;
	if( IsIconic() ) MDIRestore() ;

	SETVIEWPORT  // Just in case
}
#endif

BOOL CGraphWindow::SetActiveGraph( BOOL ReDraw )
{
	CGraphStruct *pGraph = GetGraph() ;

	// FROZEN flag postpones transfer
	// of control from a graphDestroy() dying graph to another graph
	if( !FROZEN && pGraph )
	{
		gActive = (Graph_)pGraph ;

		gDev = gActive->dev ;  // is_a CGraph object
		gSubDev = gActive->subdev ;
		gStk = gActive->stack ;
		gBox = gActive->nbox ? gBoxGet (gActive->currbox) : 0 ;

#if defined(NEW_WIN32_GRAPHS)
		SETVIEWPORT 
#endif
		if( ReDraw ) graphRedraw() ;  // repaint the newly activated graph if indicated
		return TRUE ;
	}
	else
		return FALSE ; // if active graph not changed
}

void CGraphWindow::OnChildActivate() 
{
	CMDIChildWnd::OnChildActivate();
	SetActiveGraph() ;
}

//*****************************************************************************************

// I am using the Windows Accelerator Key Table functionality
// to generate calls to KEYBOARD handler for graph to transmit special
// to transmit special keys to ACEDB, like "KEY_DOWN" et al.

#include "key.h"

void CGraphWindow::OnDownArrow() 
{
	if( graphIsBlocked() ) return ;
	CGraphStruct *pGraph = GetGraph() ;

	// if valid graph with valid KEYBOARD callback registered
	if( pGraph && pGraph->func[ KEYBOARD ] != NULL)
			( (KeyboardFunc)( pGraph->func[ KEYBOARD ] ) )( DOWN_KEY ) ;
	// graphRedraw() ;
}

void CGraphWindow::OnLeftArrow() 
{
	if( graphIsBlocked() ) return ;
	CGraphStruct *pGraph = GetGraph() ;

	// if valid graph with valid KEYBOARD callback registered
	if( pGraph && pGraph->func[ KEYBOARD ] != NULL)
			( (KeyboardFunc)( pGraph->func[ KEYBOARD ] ) )( LEFT_KEY ) ;
	// graphRedraw() ;
}

void CGraphWindow::OnRightArrow() 
{
	if( graphIsBlocked() ) return ;
	CGraphStruct *pGraph = GetGraph() ;

	// if valid graph with valid KEYBOARD callback registered
	if( pGraph && pGraph->func[ KEYBOARD ] != NULL)
			( (KeyboardFunc)( pGraph->func[ KEYBOARD ] ) )( RIGHT_KEY ) ;
	// graphRedraw() ;
}

void CGraphWindow::OnUpArrow() 
{
	if( graphIsBlocked() ) return ;
	CGraphStruct *pGraph = GetGraph() ;

	// if valid graph with valid KEYBOARD callback registered
	if( pGraph && pGraph->func[ KEYBOARD ] != NULL)
			( (KeyboardFunc)( pGraph->func[ KEYBOARD ] ) )( UP_KEY ) ;
	// graphRedraw() ;
}

void CGraphWindow::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	CMDIChildWnd::OnActivate(nState, pWndOther, bMinimized);
	
	CGraphStruct *g = GetGraph() ;
	if( (g->type == TEXT_FIT ||
		 g->type == PIXEL_FIT  )
		&& ( IsIconic() || IsZoomed() ) )
		MDIRestore() ;
}
 

UINT CGraphWindow::OnNcHitTest(CPoint point) 
{

	UINT hitType = CMDIChildWnd::OnNcHitTest(point) ;

	if(!(gActive && gDev && VIEWPTR)) return hitType ;

	if(hitType != HTCLIENT) // reset the current cursor when not in client
	{
#if defined(REALLY_VERBOSE)
		TRACE("CGraphWindow::OnNcHitTest(hitType == %d): "
			  "My cursor is %s the client window\n",
			hitType, VIEWPTR->myCursorOn()?"exiting":"outside") ;
#endif
		if( VIEWPTR->myCursorOn() ) VIEWPTR->setMyCursorOff() ;
	}
	return hitType ;
}

void CGraphWindow::PostNcDestroy() 
{
	delete this ;
}

 
